import re
import os
import yaml
import numpy as np
import pandas as pd
import argparse
from matplotlib import pyplot as plt
from matplotlib import markers, lines
import seaborn as sns

marker_list = list(markers.MarkerStyle.markers.keys())
line_list = list(lines.lineStyles.keys())
print(line_list)

from dnnseg.plot import MidpointNormalize
from dnnseg.util import sn

def parse_path(path, key_map):
    out = {}
    vars = os.path.basename(path).split('_')
    for k in key_map:
        out[k] = None
        for v in vars:
            if v.startswith(k):
                out[k] = v[len(k):]
        if out[k] is None:
            raise ValueError('Key %s not found in path %s.' % (k, path))

    return out



if __name__ == '__main__':
    argparser = argparse.ArgumentParser('''
    Collect evaluation metrics from multiple models and dump them into a table.
    ''')
    argparser.add_argument('table_paths', nargs='+', help='Path(s) to eval table generated by gather_metrics utility.')
    argparser.add_argument('key_map_path', help='Path to YAML file containing map from keys in parsed model directory path to human-readable names.')
    argparser.add_argument('-m', '--measures', nargs='+', help='Measures (column names of eval table) to plot.')
    argparser.add_argument('-H', '--heatmap', nargs='+', help='Plot as heatmap. Otherwise, plot as line chart.')
    argparser.add_argument('-M', '--plot_marginals', nargs='+', help='Dump bar plots showing mean performance by variable.')
    argparser.add_argument('-o', '--outdir', default='./eval_plots', help='Path to output directory.')
    args = argparser.parse_args()

    for path in args.table_paths:
        df = pd.read_csv(path, sep=' ')
        with open(args.key_map_path, 'r') as f:
            key_map = yaml.load(f)
        if 'key_order' in key_map:
            key_order = key_map.pop('key_order')
        else:
            key_order = sorted(list(key_map.keys()))
    
        paths = df.model_path.to_list()
        key_vals = [parse_path(x, key_map) for x in paths]
        df_new = pd.DataFrame(key_vals)
        for c in df_new.columns:
            if len(df_new[c].unique()) > 1:
                try:
                    df[key_map[c]] = df_new[c].astype(int)
                except ValueError:
                    try:
                        df[key_map[c]] = df_new[c].astype(float)
                    except ValueError:
                        df[key_map[c]] = df_new[c]
    
        columns = []
        index = []

        if args.heatmap:
            for i, c in enumerate(key_order):
                if i % 2 == 1:
                    columns.append(key_map[c])
                else:
                    index.append(key_map[c])
        else:
            assert 2 <= len(key_order) <= 3, 'For line charts, there must be either 2 or 3 variables to plot. Saw %d.' % len(key_order)
            index = key_map[key_order[0]]
            columns = [key_map[x] for x in key_order[1:]]
            n = [len(df[key_map[x]].unique()) for x in key_order[1:]]
            cm = plt.get_cmap('gist_rainbow')
            markers_keys = list(markers.MarkerStyle.markers.keys())[:-3]
            colormap = {}
            markermap = {}
            stylemap = {}

            vals = df[key_map[key_order[1]]].unique()
            n = len(vals)
            for i, v in enumerate(vals):
                colormap[v] = cm(1. * i / n)
                markermap[v] = marker_list[i]

            if len(key_order) > 2:
                vals = df[key_map[key_order[2]]].unique()
                for i, v in enumerate(vals):
                    stylemap[v] = line_list[i]

        for m in args.measures:
            pivot = df.pivot_table(index=index, columns=columns, values=m)
            pivot.dropna(axis=0, how='all', inplace=True)
            pivot.dropna(axis=1, how='all', inplace=True)

            if args.heatmap:
                ax = sns.heatmap(pivot, cmap='RdBu', center=max(0., np.nanmin(pivot.values)))
            else:
                plt.gca().spines['top'].set_visible(False)
                plt.gca().spines['right'].set_visible(False)
                plt.gca().spines['bottom'].set_visible(False)
                plt.gca().spines['left'].set_visible(False)
                plt.gca().tick_params(top='off', bottom='off', left='off', right='off', labelleft='on',
                                      labelbottom='on')
                plt.grid(b=True, which='major', axis='both', ls='--', lw=.5, c='k', alpha=.3)
                plt.axhline(y=0, lw=1, c='gray', alpha=1)
                plt.axvline(x=0, lw=1, c='gray', alpha=1)

                vars = []
                plt.xticks(pivot.index)
                for c in pivot.columns:
                    color_val = colormap[c[0]]
                    marker_val = markermap[c[0]]
                    if len(c) > 1:
                        style_val = stylemap[c[1]]
                    else:
                        style_val = '-'
                    plt.plot(pivot[c], label=', '.join([str(x) for x in c]), color=color_val, marker=marker_val, linestyle=style_val)
                plt.legend()
    
            outpath = args.outdir + '/'
            eval_name_parts = os.path.basename(path).split('.')
            if len(eval_name_parts) > 1:
               eval_name = '.'.join(eval_name_parts[:-1])
            else:
               eval_name = eval_name_parts[0]
            outpath += eval_name
            if not os.path.exists(outpath):
                os.makedirs(outpath)
            plt.savefig(outpath + '/%s.png' % m)
            plt.close('all')
    
            if args.plot_marginals:
                for c in [key_map[x] for x in key_order]:
                    ax = sns.barplot(x=c, y=m, data=df, n_boot=1000)
                    plt.savefig(outpath + '/%s_by_%s.png' % (m, sn(c)))
                    plt.close('all')

