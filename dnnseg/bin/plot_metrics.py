import sys
import re
import math
import itertools
import os
import yaml
import numpy as np
import pandas as pd
import argparse
from matplotlib import pyplot as plt
from matplotlib import markers, lines
import seaborn as sns

marker_list = list(markers.MarkerStyle.markers.keys())
line_list = list(lines.lineStyles.keys())

from dnnseg.plot import MidpointNormalize
from dnnseg.util import sn


default_measures = [
    'phn_b.*',
    'phn_w.*',
    'wrd_b.*',
    'wrd_w.*',
    'embeddings_.*macro.*'
]


def parse_path(path, key_map):
    out = {}
    vars = os.path.basename(path).split('_')
    for k in key_map:
        out[k] = None
        for v in vars:
            if v.startswith(k):
                out[k] = v[len(k):]
        if out[k] is None:
            raise ValueError('Key %s not found in path %s.' % (k, path))

    return out



if __name__ == '__main__':
    argparser = argparse.ArgumentParser('''
    Collect evaluation metrics from multiple models and dump them into a table.
    ''')
    argparser.add_argument('table_paths', nargs='+', help='Path(s) to eval table generated by gather_metrics utility.')
    argparser.add_argument('key_map_path', help='Path to YAML file containing map from keys in parsed model directory path to human-readable names.')
    argparser.add_argument('-e', '--eval_measures', nargs='+', default=default_measures, help='(List of) regex on measures (column names of eval table) to plot.')
    argparser.add_argument('-H', '--heatmap', action='store_true', help='Plot as heatmap. Otherwise, plot as line chart.')
    argparser.add_argument('-M', '--plot_marginals', nargs='+', help='Dump bar plots showing mean performance by variable.')
    argparser.add_argument('-p', '--to_percent', action='store_true', help='Multiply metrics by 100.')
    argparser.add_argument('-d', '--dump_data', action='store_true', help='Dump tabular data for each plot.')
    argparser.add_argument('-c', '--cmap', type=str, default='RdBu', help='Name of matplotlib colormap to use.')
    argparser.add_argument('-o', '--outdir', default='./eval_plots', help='Path to output directory.')
    args = argparser.parse_args()

    measures = [re.compile(x) for x in args.eval_measures]

    for path in args.table_paths:
        df = pd.read_csv(path, sep=' ')
        with open(args.key_map_path, 'r') as f:
            key_map = yaml.load(f)
        if 'key_order' in key_map:
            key_order = key_map.pop('key_order')
        else:
            key_order = sorted(list(key_map.keys()))

        cols = []
        for c in df.columns:
            for r in measures:
                if r.match(c):
                    cols.append(c)
                    break
    
        paths = df.model_path.to_list()
        key_vals = [parse_path(x, key_map) for x in paths]
        df_new = pd.DataFrame(key_vals)
        for c in df_new.columns:
            if len(df_new[c].unique()) > 1:
                try:
                    df[key_map[c]] = df_new[c].astype(int)
                except ValueError:
                    try:
                        df[key_map[c]] = df_new[c].astype(float)
                    except ValueError:
                        df[key_map[c]] = df_new[c]

        if args.heatmap:
            columns = [key_map[key_order[-1]]]
            index = [key_map[c] for c in key_order[:-1]]
        else:
            assert 2 <= len(key_order) <= 3, 'For line charts, there must be either 2 or 3 variables to plot. Saw %d.' % len(key_order)
            index = key_map[key_order[0]]
            columns = [key_map[x] for x in key_order[1:]]
            cm = plt.get_cmap(args.cmap)
            markers_keys = list(markers.MarkerStyle.markers.keys())[:-3]
            colormap = {}
            markermap = {}
            stylemap = {}

            vals = df[key_map[key_order[1]]].unique()
            n = len(vals)
            for i, v in enumerate(vals):
                colormap[v] = cm(1. * i / n)
                markermap[v] = marker_list[i]

            if len(key_order) > 2:
                vals = df[key_map[key_order[2]]].unique()
                for i, v in enumerate(vals):
                    stylemap[v] = line_list[i]

        for m in cols:
            if m in df.columns:
                outpath = args.outdir + '/'
                eval_name_parts = os.path.basename(path).split('.')
                if len(eval_name_parts) > 1:
                    eval_name = '.'.join(eval_name_parts[:-1])
                else:
                    eval_name = eval_name_parts[0]
                outpath += eval_name
                if not os.path.exists(outpath):
                    os.makedirs(outpath)

                pivot = df.pivot_table(index=index, columns=columns, values=m)
                if args.to_percent:
                    pivot *= 100
                pivot.dropna(axis=0, how='all', inplace=True)
                pivot.dropna(axis=1, how='all', inplace=True)

                if args.dump_data:
                    pivot.to_csv(outpath + '/%s_%s.csv' % (eval_name, m), sep=' ', na_rep='NaN')

                if args.heatmap:
                    levels = {c: list(pivot.index.get_level_values(c).unique()) for c in pivot.index.names}
                    levels[key_map[key_order[-1]]] = list(pivot.columns)

                vmin = np.nanmin(pivot)
                vmax = np.nanmax(pivot)

                if args.heatmap:
                    major_dims = key_order[:-2]
                    row_vars = []
                    col_vars = []
                    split = (math.ceil(len(major_dims)/2))
                    if len(major_dims) > 0:
                        for i, c in enumerate(major_dims):
                            if i < split:
                                row_vars.append(levels[key_map[c]])
                            else:
                                col_vars.append(levels[key_map[c]])

                    n_rows = 1
                    for x in row_vars:
                        n_rows *= len(x)
                    n_cols = 1
                    for x in col_vars:
                        n_cols *= len(x)

                    fig, axs = plt.subplots(n_rows, n_cols, squeeze=False)
                    fig.set_size_inches(((n_cols+1)*2, n_rows*1.5+1))
                    cbar_ax = fig.add_axes([.75, .3, .03, .4])

                    if len(row_vars):
                        row_iter = itertools.product(*row_vars)
                    else:
                        row_iter = [()]

                    for i, var_r in enumerate(row_iter):
                        if len(col_vars):
                            col_iter = itertools.product(*col_vars)
                        else:
                            col_iter = [()]
                        for j, var_c in enumerate(col_iter):
                            key = list(var_r) + list(var_c)
                            df_sub = pivot.xs(key)
                            df_sub.sort_index(ascending=False, inplace=True)

                            ax = axs[i, j]

                            sns.heatmap(
                                df_sub,
                                cbar=i==0 and j==0,
                                vmin=vmin,
                                vmax=vmax,
                                ax=ax,
                                cbar_ax=cbar_ax if (i==0 and j==0) else None,
                                cmap=args.cmap,
                                center=max(0., vmin),
                                square=True
                            )

                            row_lab_str = ''
                            col_lab_str = ''
                            for k, l in enumerate(pivot.index.names[:len(key)]):
                                if k < split:
                                    row_lab_str += '%s = %s\n' % (l, key[k])
                                else:
                                    col_lab_str += '%s = %s\n' % (l, key[k])

                            if i == (n_rows) - 1:
                                ax.set_xlabel(col_lab_str + ax.get_xlabel(), fontweight='bold')
                            else:
                                ax.set_xlabel(None)
                            ax.set_ylabel(row_lab_str + ax.get_ylabel(), fontweight='bold')

                else:
                    plt.gca().spines['top'].set_visible(False)
                    plt.gca().spines['right'].set_visible(False)
                    plt.gca().spines['bottom'].set_visible(False)
                    plt.gca().spines['left'].set_visible(False)
                    plt.gca().tick_params(top='off', bottom='off', left='off', right='off', labelleft='on',
                                          labelbottom='on')
                    plt.grid(b=True, which='major', axis='both', ls='--', lw=.5, c='k', alpha=.3)
                    plt.axhline(y=0, lw=1, c='gray', alpha=1)
                    plt.axvline(x=0, lw=1, c='gray', alpha=1)

                    vars = []
                    plt.xticks(pivot.index)
                    for c in pivot.columns:
                        color_val = colormap[c[0]]
                        marker_val = markermap[c[0]]
                        if len(c) > 1:
                            style_val = stylemap[c[1]]
                        else:
                            style_val = '-'
                        plt.plot(pivot[c], label=', '.join([str(x) for x in c]), color=color_val, marker=marker_val, linestyle=style_val)
                    plt.legend()
                    fig = plt

                fig.tight_layout()

                fig.savefig(outpath + '/%s_%s.png' % (eval_name, m))
                plt.close('all')

                if args.plot_marginals:
                    for c in [key_map[x] for x in key_order]:
                        ax = sns.barplot(x=c, y=m, data=df, n_boot=1000)
                        plt.savefig(outpath + '/%s_by_%s.png' % (m, sn(c)))
                        plt.close('all')
            else:
                sys.stderr.write('Measure %s not found in eval table. Skipping...\n')
                sys.stderr.flush()

